interface BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModel implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModelUUID implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

input BaseWhereInput {
  id_eq: String
  id_in: [String!]
  createdAt_eq: String
  createdAt_lt: String
  createdAt_lte: String
  createdAt_gt: String
  createdAt_gte: String
  createdById_eq: String
  updatedAt_eq: String
  updatedAt_lt: String
  updatedAt_lte: String
  updatedAt_gt: String
  updatedAt_gte: String
  updatedById_eq: String
  deletedAt_all: Boolean
  deletedAt_eq: String
  deletedAt_lt: String
  deletedAt_lte: String
  deletedAt_gt: String
  deletedAt_gte: String
  deletedById_eq: String
}

"""GraphQL representation of BigInt"""
scalar BigInt

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

interface DeleteResponse {
  id: ID!
}

type Heartbeat implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  blockNumber: BigInt
  authorityId: String
  validator: String
  peerId: String
  networkAddress: String
  multiAddress: Boolean
  ipv4: String
}

type HeartbeatConnection {
  totalCount: Int!
  edges: [HeartbeatEdge!]!
  pageInfo: PageInfo!
}

input HeartbeatCreateInput {
  blockNumber: String
  authorityId: String
  validator: String
  peerId: String
  networkAddress: String
  multiAddress: Boolean
  ipv4: String
}

type HeartbeatEdge {
  node: Heartbeat!
  cursor: String!
}

enum HeartbeatOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  blockNumber_ASC
  blockNumber_DESC
  authorityId_ASC
  authorityId_DESC
  validator_ASC
  validator_DESC
  peerId_ASC
  peerId_DESC
  networkAddress_ASC
  networkAddress_DESC
  multiAddress_ASC
  multiAddress_DESC
  ipv4_ASC
  ipv4_DESC
}

input HeartbeatUpdateInput {
  blockNumber: String
  authorityId: String
  validator: String
  peerId: String
  networkAddress: String
  multiAddress: Boolean
  ipv4: String
}

input HeartbeatWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  blockNumber_eq: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  authorityId_eq: String
  authorityId_contains: String
  authorityId_startsWith: String
  authorityId_endsWith: String
  authorityId_in: [String!]
  validator_eq: String
  validator_contains: String
  validator_startsWith: String
  validator_endsWith: String
  validator_in: [String!]
  peerId_eq: String
  peerId_contains: String
  peerId_startsWith: String
  peerId_endsWith: String
  peerId_in: [String!]
  networkAddress_eq: String
  networkAddress_contains: String
  networkAddress_startsWith: String
  networkAddress_endsWith: String
  networkAddress_in: [String!]
  multiAddress_eq: Boolean
  multiAddress_in: [Boolean!]
  ipv4_eq: String
  ipv4_contains: String
  ipv4_startsWith: String
  ipv4_endsWith: String
  ipv4_in: [String!]
  AND: [HeartbeatWhereInput!]
  OR: [HeartbeatWhereInput!]
}

input HeartbeatWhereUniqueInput {
  id: ID!
}

type LastHeartbeat implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  heartbeatId: String!
}

type LastHeartbeatConnection {
  totalCount: Int!
  edges: [LastHeartbeatEdge!]!
  pageInfo: PageInfo!
}

input LastHeartbeatCreateInput {
  heartbeatId: String!
}

type LastHeartbeatEdge {
  node: LastHeartbeat!
  cursor: String!
}

enum LastHeartbeatOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  heartbeatId_ASC
  heartbeatId_DESC
}

input LastHeartbeatUpdateInput {
  heartbeatId: String
}

input LastHeartbeatWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  heartbeatId_eq: String
  heartbeatId_contains: String
  heartbeatId_startsWith: String
  heartbeatId_endsWith: String
  heartbeatId_in: [String!]
  AND: [LastHeartbeatWhereInput!]
  OR: [LastHeartbeatWhereInput!]
}

input LastHeartbeatWhereUniqueInput {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type ProcessorState {
  lastCompleteBlock: Float!
  lastProcessedEvent: String!
  indexerHead: Float!
  chainHead: Float!
}

type Query {
  heartbeats(offset: Int, limit: Int = 50, where: HeartbeatWhereInput, orderBy: [HeartbeatOrderByInput!]): [Heartbeat!]!
  heartbeatByUniqueInput(where: HeartbeatWhereUniqueInput!): Heartbeat
  heartbeatsConnection(first: Int, after: String, last: Int, before: String, where: HeartbeatWhereInput, orderBy: [HeartbeatOrderByInput!]): HeartbeatConnection!
  lastHeartbeats(offset: Int, limit: Int = 50, where: LastHeartbeatWhereInput, orderBy: [LastHeartbeatOrderByInput!]): [LastHeartbeat!]!
  lastHeartbeatByUniqueInput(where: LastHeartbeatWhereUniqueInput!): LastHeartbeat
  lastHeartbeatsConnection(first: Int, after: String, last: Int, before: String, where: LastHeartbeatWhereInput, orderBy: [LastHeartbeatOrderByInput!]): LastHeartbeatConnection!
}

type StandardDeleteResponse {
  id: ID!
}

type Subscription {
  stateSubscription: ProcessorState!
}
